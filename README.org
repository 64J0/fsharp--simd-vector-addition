#+TITLE: F# SIMD Vector Addition

* Overview

This project explores how to implement and test SIMD (Single Instruction, Multiple Data) operations in F#, specifically using:

- 128-bit SIMD via SSE (~System.Runtime.Intrinsics.X86.Sse~)
- Safe memory access with ~Span<T>~ and ~MemoryMarshal.Cast~
- Automated unit testing with ~Expecto~
- Performance benchmarking with ~BenchmarkDotNet~

It compares scalar vs SIMD performance on vector addition of ~float32~ arrays.

This program uses the *intrinsics* technology, that allows us to write low-level CPU instructions directly in high-level languages like F#, C#, or C++, without writing assembly code. They expose specific hardware features (like SIMD, cryptography, etc.) as functions/methods that map directly to processor instructions.

* Features

- Safe, GC-friendly SIMD implementation (no ~unsafe~ blocks)
- Fallback to scalar operations for trailing elements
- Unit tests for correctness
- Benchmarking suite to evaluate performance benefits

* Run Unit Tests

#+BEGIN_SRC bash
dotnet test
#+END_SRC

* Run Benchmarks

Compile and run in Release mode:

#+BEGIN_SRC bash
dotnet run -c Release
#+END_SRC

Sample output:

#+BEGIN_EXAMPLE
| Method    | Mean     | Error    | StdDev   | Median   | Ratio | RatioSD |
|-----------|----------|----------|----------|----------|-------|---------|
| ScalarAdd | 83.53 ms | 1.790 ms | 5.279 ms | 80.69 ms |  1.00 |    0.09 |
| SimdAdd   | 76.15 ms | 1.216 ms | 1.401 ms | 75.55 ms |  0.92 |    0.06 |
#+END_EXAMPLE
