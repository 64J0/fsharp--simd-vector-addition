#+TITLE: F# SIMD Vector Addition
#+DATE: [2025-06-23 Mon]

** Overview

This project explores how to implement and test SIMD (Single Instruction,
Multiple Data) operations in F#, specifically using:

- 128-bit SIMD via SSE (~System.Runtime.Intrinsics.X86.Sse~, where SSE stands
  for Streaming SIMD Extensions)
- Safe memory access with ~Span<T>~ and ~MemoryMarshal.Cast~
- Automated unit testing with ~Expecto~
- Performance benchmarking with ~BenchmarkDotNet~

It compares scalar vs SIMD performance on vector addition of ~float32~ arrays.

This program uses the *intrinsics* technology, that allows us to write low-level
CPU instructions directly in high-level languages like F#, C#, or C++, without
writing assembly code. They expose specific hardware features (like SIMD,
cryptography, etc.) as functions/methods that map directly to processor
instructions.

*** Assembly code

If you'd like to check the generated x86 assembly code, check this link from
[[https://godbolt.org/z/334xh6eoj][godbolt]].

** Features

- Safe, GC-friendly SIMD implementation (no ~unsafe~ blocks)
- Fallback to scalar operations for trailing elements
- Unit tests for correctness
- Benchmarking suite to evaluate performance benefits

** Run Unit Tests

#+BEGIN_SRC bash
dotnet test
#+END_SRC

** Run Benchmarks

Compile and run in Release mode:

#+BEGIN_SRC bash
dotnet run -c Release
#+END_SRC

Sample output:

| Method    | Mean     | Error    | StdDev   | Median   | Ratio | RatioSD |
|-----------|----------|----------|----------|----------|-------|---------|
| ScalarAdd | 83.53 ms | 1.790 ms | 5.279 ms | 80.69 ms |  1.00 |    0.09 |
| SimdAdd   | 76.15 ms | 1.216 ms | 1.401 ms | 75.55 ms |  0.92 |    0.06 |

** Related projects:

- [[https://github.com/64J0/samples--assembly][64J0/samples--assembly]]
- [[https://github.com/CBGonzalez/SIMDPerformance][CBGonzalez/SIMDPerformance]]
- [[https://github.com/CBGonzalez/SIMDIntro][CBGonzalez/SIMDIntro]]
